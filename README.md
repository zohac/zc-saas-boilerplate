# ZC SaaS Boilerplate

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
<!-- Ajoutez d'autres badges ici si n√©cessaire (Build Status, Coverage, etc.) -->
<!-- [![Build Status](https://travis-ci.org/your-username/zc-saas-boilerplate.svg?branch=main)](https://travis-ci.org/your-username/zc-saas-boilerplate) -->
<!-- [![Coverage Status](https://coveralls.io/repos/github/your-username/zc-saas-boilerplate/badge.svg?branch=main)](https://coveralls.io/github/your-username/zc-saas-boilerplate?branch=main) -->

Un boilerplate robuste et bien structur√© construit avec **NestJS** pour d√©marrer rapidement le d√©veloppement d'applications SaaS (Software as a Service). Ce projet met l'accent sur la **Clean Architecture**, la **testabilit√©**, et inclut des fonctionnalit√©s communes pr√™tes √† l'emploi ou facilement extensibles.

## ‚ú® Fonctionnalit√©s Principales

*   **Fondation NestJS :** Utilise le framework Node.js moderne et puissant NestJS.
*   **TypeScript :** Typage statique pour une meilleure maintenabilit√© et productivit√©.
*   **Clean Architecture :** Structure de projet organis√©e (Domain, Application, Infrastructure, Presentation) pour une s√©paration claire des pr√©occupations.
*   **Gestion de la Configuration :** Int√©gration de `@nestjs/config` avec support des fichiers `.env` et validation optionnelle.
*   **Base de Donn√©es (TypeORM & PostgreSQL) :** Int√©gration de TypeORM avec PostgreSQL, configuration pr√™te pour les migrations.
*   **Authentification (Auth) :** Module d'authentification complet avec strat√©gies `local` (email/mot de passe) et `JWT` (JSON Web Tokens). Inclut le hachage de mot de passe (`bcrypt`).
*   **Gestion Utilisateur (User) :** Module de base pour la gestion des utilisateurs (CRUD).
*   **Validation des Donn√©es :** Utilisation de `class-validator` et `class-transformer` avec un `ValidationPipe` global.
*   **Gestion Globale des Erreurs :** Filtre d'exception HTTP personnalis√© pour des r√©ponses d'erreur coh√©rentes.
*   **S√©curit√© de Base :** Configuration de `Helmet`, `CORS`, et `Throttler` (Rate Limiting).
*   **Documentation API (Swagger) :** Int√©gration de `@nestjs/swagger` pour une documentation API auto-g√©n√©r√©e et interactive.
*   **Outillage (Linting & Formatting) :** Configuration d'ESLint et Prettier pour un code propre et coh√©rent.
*   **Dockerisation :** `Dockerfile` et `docker-compose.yml` pour un d√©veloppement et un d√©ploiement facilit√©s (App + DB PostgreSQL).
*   **Tests :** Structure de base pour les tests unitaires et E2E avec Jest.
*   **(Pr√©vu) Concepts SaaS :** Structure pr√™te √† accueillir des modules pour les Organisations, Membres, Abonnements, Invitations, etc.

## üöÄ Technologie

*   **Framework :** [NestJS](https://nestjs.com/) (^Version utilis√©e, e.g., ^10.0.0)
*   **Langage :** [TypeScript](https://www.typescriptlang.org/) (^Version utilis√©e, e.g., ^5.0.0)
*   **ORM :** [TypeORM](https://typeorm.io/)
*   **Base de Donn√©es :** [PostgreSQL](https://www.postgresql.org/)
*   **Authentification :** [PassportJS](http://www.passportjs.org/) (`passport-local`, `passport-jwt`), `@nestjs/jwt`
*   **Validation :** `class-validator`, `class-transformer`
*   **Configuration :** `@nestjs/config`
*   **Tests :** [Jest](https://jestjs.io/)
*   **API Docs :** `@nestjs/swagger`
*   **Conteneurisation :** [Docker](https://www.docker.com/), Docker Compose
*   **Linting/Formatting :** [ESLint](https://eslint.org/), [Prettier](https://prettier.io/)

## üèõÔ∏è Architecture

Ce projet suit les principes de la **Clean Architecture** pour s√©parer les diff√©rentes couches logiques de l'application :

1.  **Domain :** Contient la logique m√©tier principale, les entit√©s de domaine (interfaces ou classes simples) et les interfaces des d√©p√¥ts (repositories). N'a aucune d√©pendance externe.
2.  **Application :** Orchestre les cas d'utilisation (Use Cases) de l'application. Contient les DTOs (Data Transfer Objects), les interfaces de services externes (ports), et d√©pend du Domain.
3.  **Infrastructure :** Impl√©mente les d√©tails techniques comme l'acc√®s √† la base de donn√©es (impl√©mentation des repositories via TypeORM), les services externes (JWT, Email, etc.), l'ORM (Entit√©s TypeORM). D√©pend de l'Application (impl√©mente ses interfaces) et du Domain.
4.  **Presentation :** Point d'entr√©e de l'application (ex: API REST). Contient les Contr√¥leurs, les Guards, les Pipes, etc. D√©pend de l'Application (utilise les Use Cases).

*Voir `src/` pour la structure des dossiers impl√©mentant cette architecture.*
<!-- [Lien vers un diagramme d'architecture si disponible] -->

## üèÅ D√©marrage Rapide

### Pr√©requis

*   [Node.js](https://nodejs.org/) (Version LTS recommand√©e, v20.12.0)
*   [pnpm](https://pnpm.io/fr/)
*   [Git](https://git-scm.com/)
*   [Docker](https://www.docker.com/) & [Docker Compose](https://docs.docker.com/compose/) (pour l'environnement de d√©veloppement bas√© sur Docker)
*   Une instance PostgreSQL (si vous ne lancez pas via Docker)

### Installation

1.  **Cloner (ou Forker) le d√©p√¥t :**
    ```bash
    git clone https://github.com/votre-username/zc-saas-boilerplate.git
    cd zc-saas-boilerplate
    ```
    *(Voir la section "Utiliser ce Boilerplate" pour l'approche recommand√©e avec Fork + Upstream)*

2.  **Installer les d√©pendances :**
    ```bash
    pnpm install
    ```

### Configuration

1.  **Cr√©er le fichier d'environnement :**
    Copiez le fichier d'exemple `.env.dist` vers `.env`. Ce fichier est ignor√© par Git.
    ```bash
    cp .env.dist .env
    ```

2.  **Configurer les variables d'environnement :**
    Ouvrez le fichier `.env` et modifiez les valeurs selon votre environnement local, notamment pour la base de donn√©es et les secrets JWT.

    ```dotenv
    # Application
    NODE_ENV=development
    PORT=3000

    # Database (PostgreSQL)
    DB_HOST=localhost # ou le nom du service docker si vous utilisez docker-compose (e.g., postgres_db)
    DB_PORT=5432
    DB_USERNAME=votre_user_pg
    DB_PASSWORD=votre_mot_de_passe_pg
    DB_DATABASE=votre_nom_db_pg

    # JWT
    JWT_SECRET=VOTRE_SECRET_JWT_TRES_FORT # Changez ceci !
    JWT_EXPIRATION_TIME=3600s # Ex: 1 heure

    # Autres configurations (Mailer, Redis, etc. √† ajouter si n√©cessaire)
    # ...
    ```

### Lancement de l'Application

#### Option 1 : Localement (N√©cessite une base de donn√©es PostgreSQL en cours d'ex√©cution s√©par√©ment)

1.  **Assurez-vous que votre instance PostgreSQL est lanc√©e et accessible** avec les informations fournies dans `.env`.

2.  **Ex√©cuter les migrations (premi√®re fois ou apr√®s des changements de mod√®le) :**
    ```bash
    pnpm run migration:run
    ```

3.  **D√©marrer le serveur de d√©veloppement :**
    ```bash
    pnpm run start:dev
    ```
    L'application sera disponible sur `http://localhost:PORT` (par d√©faut `http://localhost:3000`).

#### Option 2 : Avec Docker Compose (Recommand√© pour un environnement de d√©veloppement coh√©rent)

1.  **Assurez-vous que Docker est en cours d'ex√©cution.**

2.  **Mettez √† jour `DB_HOST` dans `.env` :**
    Changez `DB_HOST=localhost` par `DB_HOST=postgres_db` (ou le nom que vous avez donn√© au service de base de donn√©es dans `docker-compose.yml`).

3.  **Lancer les services (Application + Base de donn√©es) :**
    ```bash
    docker-compose up --build
    ```
    *(Le `--build` n'est n√©cessaire que la premi√®re fois ou si vous modifiez le Dockerfile ou les d√©pendances).*

4.  **Dans un autre terminal (pendant que `docker-compose up` est en cours d'ex√©cution), ex√©cutez les migrations DANS le conteneur :**
    ```bash
    docker-compose exec api npm run migration:run
    ```
    *(Remplacez `api` par le nom du service de votre application dans `docker-compose.yml` si diff√©rent)*.

    L'application sera disponible sur `http://localhost:PORT` (par d√©faut `http://localhost:3000`) et connect√©e √† la base de donn√©es Dockeris√©e.

### Migrations de Base de Donn√©es (TypeORM)

*   **G√©n√©rer une nouvelle migration apr√®s des changements dans les entit√©s :**
    ```bash
    # Remplacez 'NomDeLaMigration' par un nom descriptif (ex: CreateUserTable)
    pnpm run migration:generate --name=NomDeLaMigration
    ```
    V√©rifiez le fichier de migration g√©n√©r√© dans `src/database/migrations`.

*   **Ex√©cuter les migrations en attente :**
    ```bash
    pnpm run migration:run
    ```

*   **Annuler la derni√®re migration ex√©cut√©e :**
    ```bash
    pnpm run migration:revert
    ```

### Tests

*   **Ex√©cuter tous les tests unitaires :**
    ```bash
    pnpm run test
    ```

*   **Ex√©cuter tous les tests End-to-End (E2E) :**
    *(N√©cessite une base de donn√©es configur√©e et potentiellement en cours d'ex√©cution)*
    ```bash
    pnpm run test:e2e
    ```

*   **Ex√©cuter tous les tests avec couverture :**
    ```bash
    pnpm run test:cov
    ```

### Linting et Formatage

*   **V√©rifier les erreurs de linting :**
    ```bash
    pnpm run lint
    ```

*   **Formater le code avec Prettier :**
    ```bash
    pnpm run format
    ```

### Documentation API (Swagger)

Une fois l'application lanc√©e (localement ou via Docker), la documentation Swagger UI est g√©n√©ralement disponible √† l'adresse :

`http://localhost:PORT/api` (par d√©faut `http://localhost:3000/api`)

Cette interface vous permet d'explorer et d'interagir avec les endpoints de l'API.

## üèóÔ∏è Structure du Projet (Aper√ßu)
```bash
zc-saas-boilerplate/
‚îú‚îÄ‚îÄ dist/ # Code compil√© (utilis√© en production)
‚îú‚îÄ‚îÄ node_modules/ # D√©pendances
‚îú‚îÄ‚îÄ src/ # Code source de l'application
‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts # Module racine
‚îÇ   ‚îú‚îÄ‚îÄ main.ts # Point d'entr√©e de l'application
‚îÇ   ‚îú‚îÄ‚îÄ config/ # Configuration de l'application (env validation, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ database/ # Configuration BDD, migrations, seeds (optionnel)
‚îÇ   ‚îú‚îÄ‚îÄ shared/ # Code partag√© (communs, filtres, pipes, d√©corateurs...)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ common/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ auth/ # Module d'Authentification
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ presentation/ (controllers, guards)
‚îÇ   ‚îú‚îÄ‚îÄ user/ # Module Utilisateur
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ presentation/ (controllers)
‚îÇ   ‚îú‚îÄ‚îÄ organization/ # (Futur) Module Organisation/Tenant
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ ... # Autres modules m√©tier
‚îú‚îÄ‚îÄ test/ # Tests E2E
‚îú‚îÄ‚îÄ .env.example # Fichier d'exemple pour les variables d'environnement
‚îú‚îÄ‚îÄ .eslintrc.js
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ .prettierrc
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ nest-cli.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md # Vous √™tes ici !
‚îî‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ tsconfig.build.json
```

## üîë Modules Cl√©s (Impl√©ment√©s / Pr√©vus)

*   **AppModule :** Module racine, assemble l'application.
*   **ConfigModule :** Chargement et validation de la configuration.
*   **DatabaseModule (via TypeOrmModule) :** Connexion et gestion de la base de donn√©es.
*   **UserModule :** Gestion des entit√©s Utilisateur.
*   **AuthModule :** Authentification (login, protection des routes via JWT).
*   **(Pr√©vu) OrganizationModule / TenantModule :** Gestion des comptes clients / locataires.
*   **(Pr√©vu) MembershipModule :** Liaison Utilisateurs <-> Organisations avec r√¥les.
*   **(Pr√©vu) BillingModule / SubscriptionModule :** Gestion des plans et abonnements.

## üí° Utiliser ce Boilerplate pour Votre Projet

L'approche recommand√©e est d'utiliser ce d√©p√¥t comme point de d√©part en le **forkant**. Cela vous permet de b√©n√©ficier des mises √† jour futures du boilerplate tout en d√©veloppant votre propre application.

1.  **Forkez** ce d√©p√¥t sur GitHub.
2.  **Clonez votre fork** sur votre machine locale :
    ```bash
    git clone https://github.com/zohac/zc-saas-boilerplate.git mon-nouveau-projet
    cd mon-nouveau-projet
    ```
3.  **(Optionnel mais Recommand√©) Configurez le d√©p√¥t original comme "upstream" :**
    ```bash
    git remote add upstream https://github.com/zohac/zc-saas-boilerplate.git
    ```
    
4.  **D√©veloppez votre application** sur votre fork.

5.  **Pour r√©cup√©rer les mises √† jour du boilerplate (si n√©cessaire) :**
    ```bash
    # R√©cup√©rer les changements de l'upstream
    git fetch upstream

    # Fusionner les changements de la branche principale de l'upstream dans votre branche actuelle
    # (R√©solvez les conflits si n√©cessaire)
    git merge upstream/main
    # OU utiliser rebase (attention si vous avez d√©j√† push√© vos changements)
    # git rebase upstream/main
    ```

## üôå Contribution

Les contributions sont les bienvenues ! Si vous souhaitez am√©liorer ce boilerplate :

1.  Forkez le d√©p√¥t.
2.  Cr√©ez une nouvelle branche (`git checkout -b feature/ma-nouvelle-feature`).
3.  Commitez vos changements (`git commit -am 'feat: Ajout de ma feature'`).
4.  Poussez vers la branche (`git push origin feature/ma-nouvelle-feature`).
5.  Ouvrez une Pull Request.

Veuillez suivre les conventions de code et ajouter des tests si pertinent.

<!-- [Lien vers des directives de contribution plus d√©taill√©es si n√©cessaire] -->

## üìÑ License

Ce projet est sous licence MIT. Voir le fichier [LICENSE](LICENSE) pour plus de d√©tails.
